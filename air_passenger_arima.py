# -*- coding: utf-8 -*-
"""Air-Passenger-Arima.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QN3l6rqgmqZ9qg1RfjQmXTVBe2TGbj-n

##Introduction
###The Air Passenger Data is a well-known dataset in time series analysis, containing the monthly totals of international airline passengers from January 1949 to December 1960. This dataset is frequently used to demonstrate various time series forecasting methods due to its clear upward trend and seasonal patterns.

###In this project, we aim to analyze this time series data to uncover underlying patterns, trends, and seasonality. We will apply the ARIMA (AutoRegressive Integrated Moving Average) model to forecast future airline passenger traffic. ARIMA is a powerful and widely-used technique for time series forecasting, capable of capturing both short-term and long-term dependencies in the data.

###Through this analysis, we will:

* Explore and visualize the data to understand its structure.
* Preprocess the dataset to make it ready for ARIMA modeling.
* Build, train, and tune the ARIMA model to predict future passenger numbers.
* Evaluate the performance of the model using appropriate metrics like Mean Absolute Error (MAE) and Root Mean Squared Error (RMSE).

###This project will offer valuable insights into forecasting techniques and their practical applications in real-world datasets, such as predicting passenger demand, optimizing flight schedules, and enhancing airline operational efficiency.

##Importing Necessary Libraries.
"""

import pandas as pd #It imports the pandas library and assigns it the alias "pd" for easier use.
import numpy as np #It brings in a tool called numpy, nicknamed "np", to help with number crunching in your code.
import matplotlib.pyplot as plt #It imports plotting tools from matplotlib, nicknamed "plt", for creating visualizations.
import seaborn as sn #It imports the seaborn library, nicknamed "sns", for making statistical visualizations

"""###Loading the Dataframe"""

df = pd.read_csv("AirPassengers (1).csv") #It reads data from the "AirPassengers (1).csv" file and stores it in a table called "df" using pandas

df

#creating a line plot of the #Passengers data from the DataFrame df
from matplotlib import pyplot as plt
df['#Passengers'].plot(kind='line', figsize=(8, 4), title='#Passengers')
plt.gca().spines[['top', 'right']].set_visible(False)

df.columns #It shows the names of all the columns in the DataFrame df.

df["Month"]= pd.to_datetime(df["Month"])
#This line converts the 'Month' column in your DataFrame (df) to datetime objects.
#This is important for time series analysis as it allows pandas to understand the temporal order of your data.
df #Shows the updated DataFrame.

from matplotlib import pyplot as plt
df['#Passengers'].plot(kind='hist', bins=20, title='#Passengers')
plt.gca().spines[['top', 'right',]].set_visible(False)
#It creates a histogram of the '#Passengers' data, with 20 bins

df.dtypes #It shows the data type of each column in the DataFrame df.

df.set_index("Month",inplace=True)
#This line sets the 'Month' column as the index of the DataFrame df. inplace=True modifies the DataFrame directly instead of creating a copy.
df #This line simply displays the DataFrame df after the index has been set.

plt.plot(df['#Passengers'])

"""Creating a simple line plot of the '#Passengers' data over time, using the 'Month' column (which was previously set as the index) as the x-axis. This visualization helps see trends and patterns in passenger numbers over time."""

from statsmodels.tsa.stattools import adfuller
adf,pvalue,usedlag_, nobs_, critical_values, icbest_ = adfuller(df)

"""It performs the Augmented Dickey-Fuller test (ADF) to check if the time series data in df is stationary and stores the results in several variables. The test helps determine if the data has a unit root, which would indicate non-stationarity."""

print(pvalue) #if pvalue > 0.05 then data is not stationary

df["year"]= [d.year for d in df.index]
#This line creates a new column called "year" in the DataFrame df.
#It populates this column by extracting the year from each value in the index (which is assumed to be a DatetimeIndex representing the 'Month').
df #This line simply displays the DataFrame df after the new column has been added.

df['month'] = df.index.strftime('%b')
#This code adds a 'month' column to the DataFrame, containing the abbreviated month names derived from the index, making it easier to analyze data based on monthly patterns or trends.
df

years= df['year'].unique()
#It gets a list of all the unique years present in the 'year' column of the DataFrame df and assigns it to the variable years.
years

sn.boxplot(x='year',y='#Passengers',data=df)

sn.boxplot(x='month', y='#Passengers', data=df)

from statsmodels.tsa.seasonal import seasonal_decompose
decompose= seasonal_decompose(df['#Passengers'],
                              model='additive'
                              )
#It breaks down the time series data in df['#Passengers'] into its seasonal, trend, and residual components using an additive model. This decomposition helps understand the underlying patterns within the data.

trend= decompose.trend #This line extracts the overall upward or downward movement (trend) from the decomposed time series data and assigns it to the variable trend.
seasonal=decompose.seasonal #This line extracts the repeating patterns or cycles (seasonality) within the data and assigns it to the variable seasonal.
residual=decompose.resid #This line extracts the remaining noise or random fluctuations (residuals) after removing the trend and seasonality and assigns it to the variable residual.

trend

seasonal

residual

plt.figure(figsize=(12,8))
plt.subplot(411)
plt.plot(df["#Passengers"],label="Orginal",color='red')
plt.legend(loc='upper left')
plt.subplot(412)
plt.plot(trend,label="Trend",color='red')
plt.legend(loc='upper left')
plt.subplot(413)
plt.plot(seasonal,label="sesonal",color='red')
plt.legend(loc='upper left')
plt.subplot(414)
plt.plot(residual,label="Residual",color='red')
plt.legend(loc='upper left')
plt.show()

!pip install pmdarima
from pmdarima.arima import auto_arima

arima_model=auto_arima(df["#Passengers"], start_p=1, d=1, q=1,
                       max_p=5, max_d=5, max_q=5, m=12,
                       start_P=0, D=1, start_Q=0, max_P=5, max_D=5, max_Q=5,
                       seasonal=True,
                       trace=True,
                       error_action='ignore',
                       supress_warning=True,
                       stepwise=True, n_fits=50)
#After executing this code, the arima_model variable will contain the best-fitting ARIMA model selected by the auto_arima function.
#This model can then be used for forecasting or further analysis of the time series data.

arima_model.summary()
#It displays a summary of the fitted ARIMA model, including details like the chosen model order, coefficients, statistical significance of the parameters, and goodness-of-fit metrics.

size = int(len(df) * 0.66)
x_train, x_test = df[:size], df[size:]
#this code divides your dataset into two subsets: one for training the ARIMA model and another for testing its performance on unseen data.

x_train.shape

x_test.shape

from statsmodels.tsa.statespace.sarimax import SARIMAX

model=SARIMAX(x_train["#Passengers"],
             order=(0,1,1),
             seasonal_order=(2,1,1,12))
result=model.fit()
result.summary()

start_index=0
end_index=len(x_train)-1
train_prediction=result.predict(start_index, end_index)
train_prediction
#It generates predictions for the training data (x_train["#Passengers"]) using the fitted SARIMAX model and stores them in train_prediction.

st_index=len(x_train)
ed_index=len(df)-1
predction=result.predict(st_index,ed_index)
predction
#this code uses the trained SARIMAX model to forecast values for the testing dataset and then shows the predicted values.

predction.plot(legend=True)
x_test['#Passengers'].plot(legend=True)
#This code plots both the predicted and actual values on the same graph.

import math
from sklearn.metrics import mean_squared_error

trainScore=math.sqrt(mean_squared_error(x_train['#Passengers'],train_prediction))
testScore=math.sqrt(mean_squared_error(x_test["#Passengers"],predction))
trainScore,testScore
#This code evaluates the performance of the SARIMAX model by calculating the RMSE for both the training and testing data. This provides insights into how well the model fits the data it was trained on and how well it generalizes to new, unseen data.

forcast=result.predict(start=len(df),
                      end=(len(df)-1)+3*12,
                      typ="levels").rename('Forecust')
#It generates forecasts for future periods using the fitted SARIMAX model.
#It predicts values from the end of the existing data (len(df)) for the next 3 years (3*12 months)

plt.figure(figsize=(12,8))
plt.plot(x_train["#Passengers"],label="Training",color='green')
plt.plot(x_test["#Passengers"],label="Test",color='blue')
plt.plot(forcast,label="Forecast",color="red")
plt.legend(loc="upper left")

"""This code creates a plot that visualizes the training data, testing data, and forecasted values on the same graph, with different colors for each and a legend to distinguish them."""

